

Handling interrupts with DPMI
[32bit code, but 48bit memory segment]

The interrupt functions are real-mode procedures; they normally can't be called in protected mode without the risk of an protection fault. So the DPMI host creates an interrupt descriptor table for the application. Initially all software interrupts (except for int 31h, 2Fh and 21h function 4Ch) or external hardware interrupts are simply directed to a handler that reflects the interrupt in real-mode, i.e. the DPMI host's default handlers switch the CPU to real-mode, issue the interrupt and switch back to protected mode. The contents of general registers and flags are passed to the real mode handler and the modified registers and flags are returned to the protected mode handler. Segment registers and stack pointer are not passed between modes. 


HINT:

The third, but only thought for compatibility purposes, is using the mem[]-arrays. These arrays map the whole 1 Mb DOS space. They shouldn't be used within new programs. To convert a segment:offset real mode address to a protected mode linear address you have to multiply the segment by 16 and add its offset. This linear address can be used in combination with the DOSMEMSELECTOR variable.

[*16:+[whatever is here]]:= Addr of memory used.


As mentioned before, there's a distinction between real mode interrupts and protected mode interrupts; the latter are protected mode programs, while the former must be real mode programs. To call a protected mode interrupt handler, an assembly 'int' call must be issued, while the other is called via the realintr() or intr() function. Consequently, a real mode interrupt then must either reside in DOS memory (<1MB) or the application must allocate a real mode callback address via the get_rm_callback() function.

Creating own interrupt handlers

Interrupt redirection with FPC pascal is done via the set_pm_interrupt() for protected mode interrupts or via the set_rm_interrupt() for real mode interrupts.

example:

//1c is sys timer.
uses
        crt,
        dos;

type 

tseginfo = record
             offset : Pointer; 
		segment : Word; 
end;

const
        int1c = $1c;

var
        oldint1c : tseginfo;
        newint1c : tseginfo;

        int1c_counter : Longint;

        int1c_ds : Word; external name '___v2prt0_ds_alias';

procedure int1c_handler; assembler;
asm
   cli
   pushw %ds
   pushw %ax
   movw %cs:int1c_ds, %ax
   movw %ax, %ds
   incl int1c_counter
   popw %ax
   popw %ds
   sti
   iret
end;

var i : Longint;

begin
     newint1c.offset := @int1c_handler;
     newint1c.segment := get_cs;
     get_pm_interrupt(int1c, oldint1c);
     Writeln('-- Press any key to exit --');
     set_pm_interrupt(int1c, newint1c);
     while (not keypressed) do begin
           gotoxy(1, wherey);
           write('Number of interrupts occured : ', int1c_counter);
     end;
     set_pm_interrupt(int1c, oldint1c);
end.



For this reason FPC supplies a pre-initialized DOS memory location within the GO32 unit. This buffer is internally used for DOS functions too and so it's contents may change when calling other procedures. It's size can be obtained with tb_size and it's linear address via transfer_buffer. Another way is to allocate a completely new DOS memory area via the global_dos_alloc function for your use and supply its real mode address. 

{


type tmeminfo = record
            available_memory : Longint; 
            available_pages : Longint;
            available_lockable_pages : Longint; 
            linear_space : Longint;
            unlocked_pages : Longint; 
            available_physical_pages : Longint;
            total_physical_pages : Longint; 
            free_linear_space : Longint;
            max_pages_in_paging_file : Longint; 
            reserved : array[0..2] of Longint;
   end;

Holds information about the memory allocation, etc.
Record entry 	Description
available_memory 	Largest available free block in bytes.
available_pages 	Maximum unlocked page allocation in pages
available_lockable_pages 	Maximum locked page allocation in pages.
linear_space 	Linear address space size in pages.
unlocked_pages 	Total number of unlocked pages.
available_physical_pages 	Total number of free pages.
total_physical_pages 	Total number of physical pages.
free_linear_space 	Free linear address space in pages.
max_pages_in_paging_file 	Size of paging file/partition in pages.

NOTE: The value of a field is -1 (0ffffffffh) if the value is unknown, it's only guaranteed, that available_memory contains a valid value. The size of the pages can be determined by the get_page_size() function.


These two types contain the data structure to pass register values to a interrupt handler or real mode callback.

This record is used to store a full 48-bit pointer. This may be either a protected mode selector:offset address or in real mode a segment:offset address, depending on application.

copytodos,copyfromdos are buffered IO calls.we should be able to replace these with a buffer 'variable' of some sort.

like a temp 512K,4096K[4MB] block size copy buffer

Program buffer;

uses dos;//this is rm mode mem construct

procedure dosalloc(var selector : word; var segment : word; size : longint);
var res : longint;
begin
     res := global_dos_alloc(size);
     selector := word(res);
     segment := word(res shr 16);
end;

procedure dosfree(selector : word);
begin
     global_dos_free(selector);
end;

type VBEInfoBuf = record
                Signature : array[0..3] of char; 
                Version : Word;
                reserved : array[0..505] of byte; 
     end;

var selector,       
    segment : Word; 

    r : trealregs;  
    infobuf : VBEInfoBuf;

begin
     fillchar(r, sizeof(r), 0);
     fillchar(infobuf, sizeof(VBEInfoBuf), 0);
     dosalloc(selector, segment, sizeof(VBEInfoBuf));
     if (int31error<>0) then begin
        Writeln('Error while allocating real mode memory, halting');
        halt;
     end;
     infobuf.Signature := 'VBE2';
     dosmemput(segment, 0, infobuf, sizeof(infobuf));
     r.ax := $4f00; r.es := segment;
     realintr($10, r);
     dosmemget(segment, 0, infobuf, sizeof(infobuf));
     dosfree(selector);
     if (r.ax <> $4f) then begin
        Writeln('VBE BIOS extension not available, function call failed');
        halt;
     end;
     if (infobuf.signature[0] = 'V') and (infobuf.signature[1] = 'E') and
        (infobuf.signature[2] = 'S') and (infobuf.signature[3] = 'A') then begin
        Writeln('VBE version ', hi(infobuf.version), '.', lo(infobuf.version), ' detected');
     end;
end.

http://www.math.uni-hamburg.de/it/software/fpk/units/units.html
apple OS programming[fileIO???]:
http://developer.apple.com/documentation/Mac/Files/Files-390.html
[obsolete, but does offer HOW-TO]
aparent mac os 8/9 developers can link into pascal,c, and asm functions.
main page:
http://developer.apple.com/documentation/macos8/mac8.html
[pascal supported since the apple ][e

